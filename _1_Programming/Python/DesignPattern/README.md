# 《大话设计结构》
### 原则
面向对象：可维护、可复用、可扩展、灵活性好
类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象抽象集合才是类

单一职责原则：
就一个类而言，应该只有一个引起它变化的原因
如果一个类承担的职责过多，一个职责的变化可能会削弱或限制这个类完成其他职责的能力
如果有多于一个的动机去改变一个类，那么这个类就有多于一个的职责

开闭原则：
软件实体（类、模块、函数）对扩展开放，对修改封闭
仅对频繁变化的部分做出抽象，不需要对每个部分都刻意抽象

依赖倒转原则：
高层模块不应该依赖底层模块，两个都应该依赖抽象
抽象不应该依赖细节，细节应该依赖于抽象

里氏代换原则：
子类型必须能够替换掉他们的父类型
子类型的可替换性使父类型模块在无需修改的情况下就可扩展

迪米特法则：（最少知识原则）
如果两个类不直接通信，那么这两个类就不应该发生直接的相互作用
如果一个类要调用另一个类的某个方法，可以通过第三者转发这个调用
每一个类都应该尽量降低成员的访问权限
强调类之间的松耦合

合成/聚合复用原则：尽量使用合成/聚合，而不是类的继承
聚合：“弱拥有”关系，A可以包含B，但B不是A的一部分——大雁&雁群
合成：“强拥有”关系，A包含B，AB生命周期一样——大雁&翅膀


### 模式
简单工厂模式：
计算器程序：
封装：业务逻辑与界面逻辑分开
继承：实现运算基类，每个运算继承自基类
多态：使用简单工厂类来实例化运算类

策略模式：
定义算法家族，分别封装，算法之间可以互相替换，不会影响到使用算法的客户
Strategy类为Context定义了一系列可供重用的算法或行为

装饰模式：
动态地给一个对象添加一些额外的职责（比生成子类更灵活）
保证装饰类之间彼此独立，以免产生数据冲突

针对接口编程，不要针对实现编程

代理模式：
为其他对象提供一种代理以控制对这个对象的访问
Subject类定义真实类和Proxy的共用接口
应用：
远程代理：windows webservice，web reference
虚拟代理：HTML用虚拟代理替代真实图片，加快网页加载性能
安全代理：控制真实访问对象的权限
智能指针：调用真实对象时，代理处理另外的事，如计算真实对象的引用次数

工厂方法模式：
简单工厂 中增加实例类还需要修改工厂类方法
工厂方法定义一个用于创建对象的接口，让子类决定实例化哪个类

原型模式：
用原型实例制定创建对象的种类
通过拷贝原型创建新的对象

模板方法模式：
定义一个操作中算法的骨架，将一些步骤延迟到子类
使子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤
把不变的行为放在超类，去除子类中重复的代码

外观模式：
为子系统的一组接口提供一致的界面，定义一个高层接口
设计初期分层，开发阶段减少复杂代码之间的依赖，维护阶段用Facade与遗留代码交互
组合子系统各模块的功能，对外提供高层接口

建造者模式：（生成器模式）
把一个复杂对象的构建与表示分离，使同样的构建过程可以创建不同的表示
Director用来控制建造过程，隔离用户与建造过程的关联
适用于：创建复杂对象的算法独立于该对象的组成部分以及装配方式

观察者模式：（发布-订阅模式）
定义了一种一对多的依赖关系，让多个观察者对象同事监听某一个主题对象
主题对象Subject状态发生变化时会通知所有观察者Observe自动更新
委托：对函数抽象的类，委托实例代表一个具体的函数，委托对象所搭载的所有方法必须具有相同的参数列表和返回值类型

抽象工厂模式：
提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类

状态模式：
当一个对象内在状态改变时，允许改变其行为
把对象状态转换的判断逻辑转移到表示不同状态的一系列类，可以简化判断逻辑，消除庞大的条件分支语句

适配器模式：
将一个类的接口转换成另一些接口，使其兼容

备忘录模式：
不破坏封装性的前提下捕获一个类的内部状态，并在该对象之外保存这个状态

组合模式：
将对象组合成树形结构表示“部分-整体”
单个对象和组合对象的使用具有一致性

迭代器模式：
提供一种方法顺序访问一个聚合对象中各个元素，又不暴露该对象的内部表示（Python：Iterable）

单例模式：
让类负责保存它的唯一实例（在第一次被引用时实例化）
if(GetInstance() == null):init instance
else: return instance
多线程中的单例需要使用lock
静态初始化：在自己被加载时就将自己实例化

桥接模式：
将抽象部分与它的实现部分分离

命令模式：
将一个请求封装成一个对象，从而可以使用不同的请求对客户进行参数化

职责链模式：
多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系
沿对象链传递请求，直到有一个对象处理它为止

中介者模式：
用一个中介对象封装一系列的对象交互

享元模式：
运用共享技术有效支持大量细粒度的对象
内部状态：享元对象内不随环境改变的部分（棋的颜色）
外部状态：随环境改变的状态（棋的位置）

解释器模式：
给定一个语言，定义它的文法表示，并定义一个解释器用来解释语言中的句子
eg：正则表达式、HTML解析，编译器

访问者模式：
表示一个作用于某对象结构中的各元素的操作
可以在不改变各元素的类的前提下定义作用于这些元素的新操作
适用于数据结构相对稳定的系统，把数据结构与操作解耦，使操作可以自由演化
