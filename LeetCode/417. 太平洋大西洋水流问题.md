### 417. 太平洋大西洋水流问题（2022.04.27 每日一题）



有一个 m × n 的矩形岛屿，与 太平洋 和 大西洋 相邻。 “太平洋” 处于大陆的左边界和上边界，而 “大西洋” 处于大陆的右边界和下边界。

这个岛被分割成一个由若干方形单元格组成的网格。给定一个 m x n 的整数矩阵 heights ， heights[r][c] 表示坐标 (r, c) 上单元格 高于海平面的高度 。

岛上雨水较多，如果相邻单元格的高度 小于或等于 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。

返回 网格坐标 result 的 2D列表 ，其中 result[i] = [ri, ci] 表示雨水可以从单元格 (ri, ci) 流向 太平洋和大西洋 。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/pacific-atlantic-water-flow
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。


#### 1、递归

好久不做题目，读题都读了半天。

分析了一下，大概意思就是对于二维数组中的每个元素，如果能同时 向上或左、向下或右 连通到边界，则记录到结果数组。

第一个框架方向出来了，使用递归：

```python
class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        def can_flow_pac(px, py):
            # left or up
            pass

        def can_flow_atlan(px, py):
            # right or down
            pass

        result = []
        rows_len = len(heights)
        if not rows_len:
            return result
        cols_len = len(heights[0])
        for i in range(rows_len):
            for j in range(cols_len):
                if can_flow_pac(i, j) and can_flow_atlan(i, j):
                    result.append([i, j])
        return result

```

对于子方法can_flow_pac，只要满足:
（1）当前点(px,py)的高度大于等于上方的点(px-1, py)，且can_flow_pac(px-1, py)为True
（2）或当前点(px,py)的高度大于等于左侧的点(px, py-1)，且can_flow_pac(px, py-1)为True
（3）或当前点处于边界，即px=0或py=0
（4）当前点上方和左侧都比它高，则直接返回False，不需要再递归

而can_flow_atlan类似，-1换为+1，边界条件换为rows_len-1、cols_len-1.

一个比较粗糙的解法就完成了：

```python
from typing import List


class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        def can_flow_pac(px, py):
            # left or up
            if px == 0 or py == 0:
                return True
            if heights[px][py] < heights[px - 1][py] and heights[px][py] < heights[px][py - 1]:
                return False
            if heights[px][py] >= heights[px - 1][py] and can_flow_pac(px - 1, py):
                return True
            if heights[px][py - 1] >= heights[px][py - 1] and can_flow_pac(px, py - 1):
                return True
            return False

        def can_flow_atlan(px, py):
            # right or down
            if px == len(heights) - 1 or py == len(heights[0]) - 1:
                return True
            if heights[px][py] < heights[px + 1][py] and heights[px][py] < heights[px][py + 1]:
                return False
            if heights[px][py] >= heights[px + 1][py] and can_flow_atlan(px + 1, py):
                return True
            if heights[px][py + 1] >= heights[px][py + 1] and can_flow_atlan(px, py + 1):
                return True
            return False

        result = []
        rows_len = len(heights)
        if not rows_len:
            return result
        cols_len = len(heights[0])
        for i in range(rows_len):
            for j in range(cols_len):
                if can_flow_pac(i, j) and can_flow_atlan(i, j):
                    result.append([i, j])
        return result


if __name__ == '__main__':
    heights = [[1, 2, 2, 3, 5], [3, 2, 3, 4, 4], [2, 4, 5, 3, 1], [6, 7, 1, 4, 5], [5, 1, 1, 2, 4]]
    print(Solution().pacificAtlantic(heights))

```

不出意外呢，这个解法还是出了些意外，但是由于这个逻辑太复杂以至于懒得调试，所以就开始找别的思路。

#### 2、从边缘到目标

第一种解法是从目标点出发，尝试往边缘走，这样必然会带来一些重复计算，例如在计算(i,j)时，又计算了上下左右各四次。

那反过来，如果从海洋向陆地进发，是不是就可以每条路径只计算一次？

既然已知heights[i][j]的高度一定大于等于0，那么在已知矩阵外围补一圈值为0的点，然后看那些点能同时触达两个目标即可。

看了下出bug的点在于，实际上这个题目要计算的是图的路径，也就是说可以绕回来，这样的话就要用图的遍历算法，例如DFS或BFS。

(有空再做）
