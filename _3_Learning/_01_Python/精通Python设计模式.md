#创建型模式：处理对象创建相关问题（__init__)
##工厂模式
###两种形式
####工厂方法（Factory Method）
#####以一个函数对不同的输入参数返回不同的对象
####抽象工厂（Abstract Factory）
#####一组用于创建一系列相关事务对象的工厂方法
#####每个工厂方法负责产生不同种类的对象
###好处
####简化对象的创建：创建对象的客户端无需知道使用哪个类生成这个对象（对象创建与使用解耦）
####基于一个中心化函数来实现，更易追踪创建了那些对象
####在有必要时才创建新对象，从而提高性能和内存使用率
##建造者模式
###构造与表现分离
####一个对象必须经过多个步骤来创建
####同一个构造过程可以产生不同的表现
####与工厂区别：在客户端请求后，指挥者才返回最终的对象
#####工厂：购买一个iMac xxx型号
#####建造者：购买一个定制PC，指挥者指定内存、CPU、...规格，建造者创建具体硬件的实例
###有两个参与者
####建造者(builder)
#####负责创建复杂对象的各个组成部分
####指挥者(director)
#####使用一个建造者实例控制建造的过程
###流利的建造者
####将建造者本身定义为内部类（class Pizza： class PizzaBuilder：)
####每个设置器方法返回自身（return self）
####方法build()返回最终的对象（return Pizza(self) ）
##原型模式
###创建对象的克隆
####clone()函数：接受一个对象作为输入参数，返回输入对象的一个副本
####copy.deepcopy()函数：创建一个被克隆对象的副本（与原对象地址不同）
###需求场景
####已知对象的某些地方会被变更，但原有对象保持不变
#####重新创建原有对象没有意义
####需要复制一个复杂对象
#####不通过多次重复查询数据来创建一个对象
###引用与副本
####引用
#####多个引用共享一个对象，所有变更皆可见
####副本
#####深副本
######原始对象的所有数据都被复制到克隆对象中
######copy.deepcopy(): 构造一个新的复合对象后，会递归地在原始对象中找到对象的副本，插入新对象中
#####浅副本
######依赖引用
######可用资源有限或性能要求高时
######copy.copy(): 构造一个新的复合对象后，会尽可能地在原始对象中找到对象的引用，插入新对象中
#结构型模式：处理一个系统中不同实体之间的关系
##适配器模式
###实现两个不兼容接口之间的兼容（接口一致性）
###编写一个额外的代码层，包含让两个接口之间能通信需要进行的所有修改
###实现
####使用类的内部字典，而不是继承（无需子类）
####适配器类的初始化：self.__dict__.update(adapted_methods)
####adapted_methods：一个字典，绑定了原始类方法与新增类方法（dict(execute=synth.play)）
####使用适配器后，实际实例化的是适配器类，适配器对象中包含新增类的对象，和一个映射了原始类与新增类方法的字典
####在调用适配器的原始类同名方法时，适配器会根据映射去执行新增类的对应方法
##修饰器模式
###以透明的方式（不影响其他对象）动态地扩展一个对象的功能
###实现
####使用python内置的修饰器特性
####Python修饰器是一个可调用对象（函数、方法、类）
####接受一个函数对象fin作为输入，返回另一个函数对象fout
##外观模式
###在已有复杂系统上实现一个抽象层，隐藏内部复杂性，为复杂系统提供单个简单的入口点
###多层系统中，可以每层引入一个外观入口点，并让所有层级通过它们的外观相互通信
##享元模式
###通过为相似对象引入数据共享来最小化内存使用，提升性能
###一个享元(Flyweight)就是一个包含状态独立的不可变数据的共享对象
###依赖状态的可变数据（非固有数据）不应该是享元的一部分
###对象ID对于应用不重要（对象共享会造成ID比较失败，客户端代码认为的不同对象，最终具有相同ID）
###与memorization的区别
####memorization使用一个缓存来避免重复计算那些在先前步骤中已经计算好的结果，可应用于方法和简单的函数
####享元关注的是共享对象数据，是针对面向对象编程优化的设计模式
###实现
####使用__new__方法（会在__init__之前被调用），把Tree类变成一个元类，元类支持自引用
####享元不知道的可变信息（非固有属性），由客户端代码显式传递
##MVC模式
###SoC（关注点分离）原则：将一个应用切分成不同部分，每个部分解决一个单独的关键点
####数据访问层
####业务逻辑层
####表示层
###模型-视图-控制器：面向对象编程的SoC原则
####模型：应用的信息本源
#####管理（业务）逻辑
#####数据
#####状态
#####应用的规则
####视图：模型的可视化表现
#####例子：图形用户界面、终端文本输出
#####只展示数据，并不处理数据
####控制器：模型与视图之间的链接、通信
#####无需修改模型就能使用多个视图
#####实现模型与其表现的解耦
###实现
####智能模型
#####包含所有的校验、业务规则、逻辑
#####处理应用的状态
#####访问应用数据（数据库、云、etc)
#####不依赖UI
####瘦控制器
#####在用户与视图交互时更新模型
#####在模型改变时，更新视图
#####在数据传递给模型/视图前进行处理
#####不展示数据
#####不直接访问应用数据
#####不包含校验/业务规则/逻辑
####傻瓜视图
#####展示数据
#####允许用户与其交互
#####仅做最小的数据处理（通常由一种模板语言提供处理能力）
#####不存储任何数据
#####不直接访问应用数据
#####不包含校验/业务规则/逻辑
##代理模式
###应用
####访问敏感信息前先确认有足够权限
####延迟初始化：把一个计算成本较高的对象创建过程延迟的用户首次真正使用之前
###知名代理类型
####远程代理：实际存在于不同地址空间（如网络服务器）的对象在本地的代理者
####虚拟代理：懒初始化，将大计算量的对象创建延迟到需要时
#####实例级
######对一个对象的特性进行懒初始化
######该特性有一个对象作用域
######同一个类的每个实例都有自己的特性副本
#####类/模块级
######所有实例共享一个特性
####保护/防护代理：控制对敏感对象的访问
####智能（引用）代理：对象被访问时执行额外动作（计数、线程安全检查等)
#行为型模式：处理对象互联和算法
##责任链模式
###让多个对象处理单个请求，或预先不知道应该由（对象链的）哪个对象来处理特定请求
###解耦客户端与处理程序：不再是多对多关系，客户端只需要知道责任链的起始节点
###原则
####存在一个对象链（链表、树、etc）
####一开始将请求发送给链中的第一个对象（客户端只需要知道这一个对象，不需要知道所有节点）
####对象决定是否处理这个请求
####对象将请求转发给下一个对象（每个节点只知道自己的后继节点）
####重复该过程直到到达链尾
##命令模式
###把操作（撤销、重做、复制、粘贴等）封装成一个对象
###不需要在命令创建时直接执行一个命令
###调用者无需知道命令的实现细节
###分组多个命令，调用者可以按一定顺序执行
##解释器模式
###DSL语言（领域特定语言）：针对一个特定领域的有限表达能力的计算机语言
####内部DSL：构建在宿主编程语言之上
#####优势：无需担心创建、编译、解析语法
#####劣势：受限于宿主语言的特性
####外部DSL：不依赖某种宿主语言
#####需要自定义语法、句法
#####需要创建解析器和编译器
###解释器模式仅与内部DSL相关
###应仅应用于实现简单的语言
##观察者模式
###仅在一个对象的状态改变时更新另外一组对象
####单个对象：发布者（可观察者）
#####MVC中：模型
####多个对象：订阅者（观察者）
#####MVC中：视图
##状态模式
###状态机
####状态图：每个状态是一个节点，每个转换是两个节点的边
####状态机编译器（State Machine Compiler）
####状态：一个系统当前的状况（任意时间点只有一个激活状态）
####转换：从当前状态到新状态的切换
##策略模式
###运行时透明地切换算法，客户端代码对算法无感知
###命名元组(namedtuple)
####易创建、轻量、不可变
####与普通元组兼容
####可以看做一个对象（通过类名称调用）
#####在关注不可变对象时，替代一个类
#####在使用对象表达法时替代一个元组
###应用
####使用策略模式支持不同的排序算法
####创建不同的资源过滤器
####创建不同的样式表现（可移植性）
####使用不同的策略建模
###实现
####每个策略用不同的类
####Python中可以把函数看做普通的变量
##模板模式
###消除代码冗余：无需改变算法结构就能重新定义算法的某些部分
###Python中不强制使用继承
